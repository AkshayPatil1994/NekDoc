\subsection*{An example of specifying surface normals in the .usr file}
\begin{verbatim}

c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer e,eg,f
      real snx,sny,snz   ! surface normals

      f = eface1(iside)
      e = gllel (eg)

      if (f.eq.1.or.f.eq.2) then      ! "r face"
         snx = unx(iy,iz,iside,e)                 ! Note:  iy,iz
         sny = uny(iy,iz,iside,e)
         snz = unz(iy,iz,iside,e)
      elseif (f.eq.3.or.f.eq.4)  then ! "s face"
         snx = unx(ix,iz,iside,e)                 !        ix,iz
         sny = uny(ix,iz,iside,e)
         snz = unz(ix,iz,iside,e)
      elseif (f.eq.5.or.f.eq.6)  then ! "t face"
         snx = unx(ix,iy,iside,e)                 !        ix,iy
         sny = uny(ix,iy,iside,e)
         snz = unz(ix,iy,iside,e)
      endif

      ux=0.0
      uy=0.0
      uz=0.0
      temp=0.0

      return
      end
\end{verbatim}  
This example will load a list of field files (filenames are read from a file) into the solver using the load\_ fld() function. After the data is loaded, the user is free to compute other postprocessing quantities. At the end the results are dumped onto a regular (uniform) mesh by a subsequent call to prepost().

Note: The regular grid data (field files) cannot be used as a restart file (uniform->GLL interpolation is unstable)!


     SUBROUTINE USERCHK
     INCLUDE 'SIZE'
     INCLUDE 'TOTAL'
     INCLUDE 'RESTART' 

     character*80 filename(9999)

     ntot   = nx1*ny1*nz1*nelv

     ifreguo = .true.   ! dump on regular (uniform) grid instead of GLL
     nrg     = 16       ! dimension of regular grid (nrg**ndim)
 
     ! read file-list
     if (nid.eq.0) then
        open(unit=199,file='file.list',form='formatted',status='old')
        read(199,*) nfiles
        read(199,'(A80)') (filename(i),i=1,nfiles)
        close(199)
     endif
     call bcast(nfiles,isize)
     call bcast(filename,nfiles*80)       

     do i = 1,nfiles
        call load\_ fld(filename(i))

        ! do something
        ! note: make sure you save the result into arrays which are
        !       dumped by prepost() e.g. T(nx1,ny1,nz1,nelt,ldimt)
        ...

        ! dump results into file
        call prepost(.true.,'his')
     enddo

     ! we're done
     call exitt

Spectral Interpolation Tool

Check intpts().
Monitor Points

Multiple monitor points can be defined in the file hpts.in to examine the field data at every timestep.

    setup an ASCII file called 'hpts.in' e.g: 

3 !number of monitoring points
1.1 -1.2 1.0
. . .
x y z

    depending on the number number of monitoring points you may need to increase lhis in SIZE
    add 'call hpts()' to userchk() 

Grid to Grid Interpolation

To interpolate an existing field file (e.g. base.fld) onto a new mesh do the following:

    set lpart in SIZE to a large value (e.g. 100'000 or larger) depending on your memory footprint
    compile Nek with MPIIO support
    set NSTEPS=0 in the .rea file (post-processing mode)
    run nek using the new geometry (e.g. new\_ geom.f0000)
    run nek using the old geometry and add this code snipplet to userchk() 

      character*132  newfld, oldfld, newgfld
      data newfld, oldfld, newgfld /'new0.f0001','base.fld','new\_ geom.f0000'/
c
      call g2gi(newfld, oldfld, newgfld) ! grid2grid interpolation
      call exitt()

Lagrangian Particle Tracking

The interpolation tool can be used for Lagrangian particle tracking (the particles are the interpolation points).

Workflow:

    set initial particle positions (e.g. reading a file particle.pos0) x\_ part <- x\_ pos0 

LOOP

    compute field quantities
    interpolate field quantities for all particles using intpts()
    dump/store particle data
    advect particles using particle\_ advect() 

END LOOP

\begin{verbatim}
    subroutine particle\_ advect(rtl,mr,npart,dt\_ p)
c     
c     Advance particle position in time using 4th-order Adams-Bashford.
c     U[x\_ i(t)] for a given x\_ i(t) will be evaluated by spectral interpolation.
c     Note: The particle timestep dt\_ p has be constant!
c
     include 'SIZE'
     include 'TOTAL'
        
     real rtl(mr,1)
         
     real vell(ldim,3,lpart)  ! lagged velocities 
     save vell
        
     integer icalld
     save    icalld
     data    icalld /0/
        
     if(npart.gt.lpart) then
       write(6,*) 'ABORT: npart>lpart - increase lpart in SIZE. ',nid
       call exitt
     endif 
        
    ! compute AB coefficients (for constant timestep)
     if (icalld.eq.0) then
        call rzero(vell,3*ldim*npart) ! k = 1 
        c0 = 1.
        c1 = 0.
        c2 = 0.
        c3 = 0.                       
        icalld = 1
     elseif (icalld.eq.1) then        ! k = 2
        c0 = 1.5
        c1 = -.5
        c2 = 0.
        c3 = 0.
        icalld = 2
     elseif (icalld.eq.2) then        ! k = 3
        c0 = 23.
        c1 = -16.
        c2 = 5.
        c0 = c0/12.
        c1 = c1/12.
        c2 = c2/12.
        c3 = 0.
        icalld = 3
     else                             ! k = 4
        c0 = 55.
        c1 = -59.
        c2 = 37.
        c3 = -9.
        c0 = c0/24.
        c1 = c1/24.
        c2 = c2/24.
        c3 = c3/24.
     endif

     ! compute new position x[t(n+1)]
     do i=1,npart
        do k=1,ndim
           vv = rtl(1+2*ndim+k,i)
           rtl(1+k,i) =  rtl(1+k,i) +
    \&                    dt_p*(
    \&                    + c0*vv
    \&                    + c1*vell(k,1,i)
    \&                    + c2*vell(k,2,i)
    \&                    + c3*vell(k,3,i)
    \&                    )
           ! store velocity history 
           vell(k,3,i) = vell(k,2,i)
           vell(k,2,i) = vell(k,1,i)
           vell(k,1,i) = vv
        enddo
     enddo

     return
     end
  \end{verbatim}  